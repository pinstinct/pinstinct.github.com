---
layout: post
title: 모던 자바 인 액션 - Part5
categories: book
tags: [book, java]
excerpt: 책을 읽고 정리한 내용입니다.
---

[모던 자바 인 액션](https://www.yes24.com/Product/Goods/77125987) 책을 읽고 정리한 내용입니다.

> [Repository](https://github.com/pinstinct/java-in-action)

## Part5 개선된 자바 동시성

### Chapter15. CompletableFuture와 리액티브 프로그래밍 컨셉의 기초

- 최근 소프트웨어 개발 방법을 획기적으로 뒤집는 두 가지 추세가 있다.
  - 멀티코어 프로세서가 발전하면서 애플리케이션의 속도는 멀티코어 프로세서를 얼마나 잘 활용할 수 있도록 소프트웨어를 개발하는가에 따라 달라질 수 있음을 확인했다.
  - 하나의 거대한 애플리케이션 대신 작은 서비스로 애플리케이션을 나누는 것이다. 서비스가 작아진 대신 네트워크 통신이 증가한다.
    - 이런 애플리케이션을 구현하려면 인터네승로 여러 웹 서비스에 접근해야 한다. 하지만 이들 서비스의 응답을 기다리는 동안 연산이 블록되거나 귀중한 CPU 클록 사이클 자원을 낭비하고 싶진 않다. 포크/조인 프레임워크와 병렬 스트림은 병렬성의 귀중한 도구다.
  - 반면 병렬성이 아니라 동시성을 필요로 하는 상황 즉 조금씩 연관된 작업을 같은 CPU에서 동작하는 것 또는 애플리케이션의 생산성을 극대화할 수 있도록 코어를 바쁘게 유지하는 것이 목표라면, 원격 서비스나 데이터베이스 결과를 기다리는 스레드를 블록함으로 연산 자원을 낭비하는 일은 피해야 한다. 
    - 자바는 이런 환경에서 사용할 수 있는 도구를 제공한다. Future 인터페이스로 CompletableFuture 구현(자바 8)은 간단하고 효율적인 문제 해결사다. 최근 자바 9에 추가된 발행 구독 프로토콜에 기반한 리액티브 프로그래밍 개념을 따르는 플로 API는 조금 더 정교한 프로그래밍 접근 방법을 제공한다.
  
#### 동시성을 구현하는 자바 지원의 진화 

- 처음에는 Runnable과 Thread를 동기화된 클래스와 메서드를 이용해 잠갔다.
- 자바 5는 스레드 실행과 태스크 제출을 분리하는 ExecutorService 인터페이스를 지원
- 자바 7에서는 분할 그리고 정복 알고리즘의 포크/조인 구현을 지원하는 java.util.concurrent.RecursiveTask 추가
- 자바 8에서는 스트림과 람다 지원에 기반한 병렬 프로세싱 추가
- 자바 9에서는 분산 비동기 프로그래밍을 명시적으로 지원
- CompletableFuture와 java.util.concurrent.Flow의 궁극적인 목표는 가능한한 동시에 실행할 수 있는 독립적인 태스크를 가능하게 만들면서 멀티코어 또는 여러 기기를 통해 제공되는 병렬성을 쉽게 이용하는 것이다.
- Executor와 스레드 풀
  - 자바 5는 Executor 프레임워크와 스레드 풀을 통해 스레드 힘을 높은 수준으로 끌어올리는 즉 자바 프로그래머가 태스크 제출과 실행을 분리할 수 있는 기능을 제공했다.
  - 스레드의 문제: 자바 스레드는 직접 운영체제 스레드에 접근한다. 운영체제 스레드를 만들고 종료하려면 비싼 비용을 치러야 하며 더욱이 운영체제 스레드의 숫자는 제한되어 있는 것이 문제다.
  - 스레드 풀 그리고 스레드 풀이 더 좋은 이유: ExecutorService는 태스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공한다. newFixedThreadPool 같은 팩토리 메서드 중 하나를 이용해 스레드 풀을 만들어 사용할 수 있다. 이 메서드는 워커 스레드라 불리는 nThreads를 포함하는 ExecutorService를 만들고 이들을 스레드 풀에 저장한다. 스레드 풀에서 사용하지 않는 스레드로 제출된 태스크를 먼저 온 순서대로 실행한다. 이들 태스크 실행이 종료되면 스레드를 풀로 반환한다. 이 방식의 장점은 하드웨어에 맞는 수의 태스크를 유지함과 동시에 수 천개의 테스크를 스레드 풀에 아무 오버헤드 없이 제출할 수 있다는 점이다.
  - 스레드 풀 그리고 스레드 풀이 나쁜 이유: 거의 모든 관점에서 스레드를 직접 사용하는 것보다 스레드 풀을 이용하는 것이 바람직하지만 두 가지 "사항"을 주의해야 한다.
    - k 스레드를 가진 스레드 풀은 오직 k만큼의 스레드를 동시에 실행할 수 있다. 초과로 제출된 태스크는 큐에 저장되며 이전에 태스크 중 하나가 종료되기 전까지는 스레드에 할당하지 않는다. I/O를 기다리는 태스크가 있다면 주의해야 한다. 이들 태스크가 워커 스레드에 할당된 상태를 유지하지만 아무 작업도 하지 않게 된다. 핵심은 블록(자거나 이벤트를 기다리는)할 수 있는 태스크는 스레드 풀에 제출하지 말야아 한다는 것이지만 항상 이를 지킬 수 있는 것은 아니다.
    - 프로그램을 종료하기 전에 모든 스레드 풀을 종료하는 습관을 갖는 것이 중요하다. 자바는 이런 상황을 다룰 수 있도록 Thread.setDaemon 메서드를 제공한다.
  - 스레드의 다른 추상화: 중첩되지 않은 메서드 호출
    - 엄격한 포크/조인: 태스크나 스레드가 메서드 호출 안에서 시작되면 그 메서드 호출은 반환하지 않고 작업이 끝나기를 기다린다.
    - 여유로운 방식의 포크/조인: 시작된 태스크를 내부 호출이 아니라 외부 호출에서 종료하도록 기다린다.
      - 사용자의 메서드 호출에 의해 스레드가 생성되고 메서드를 벗어나 계속 실행되는 동시성 형태에 초점을 둔다. 이런 종류, 특히 메서드 호출자에 기능을 제공하도록 메서드가 반환된 후에도 만들어진 태스크 실행이 계속되는 메서드를 비동기 메서드라 한다.
      - 비동기 메서드를 사용할 때 따르는 위험성
        - 스레드 실행은 메서드를 호출환 다음의 코드와 동시에 실행되므로 데이터 경쟁 문제를 일으키지 않도록 주의해야 한다.
        - 기존 실행 중이던 스레드가 종료되지 않은 상황에서 자바의 main() 메서드가 반환되면 어떻게 될까? 다음과 같은 두 가지 방법이 있는데 어느 방법도 안전하지 못하다.
          - 애플리케이션을 종료하지 못하고 모든 스레드가 실행을 끝낼 때까지 기다린다.
          - 애플리케이션 종료를 방해하는 스레드를 강제종료(kill) 시키고 애플리케이션을 종료한다.
        - 자바 스레드는 setDaemon() 메서드를 이용해 **데몬(daemon)** 또는 비데몬으로 구분시킬 수 있다. 데몬 스레드는 애플리케이션이 종료될 때 강제 종료되므로 디스크의 데이터 일관성을 파괴하지 않는 동작을 수행할 때 유용하게 활용할 수 있는 반면, main() 메서드는 모든 비데몬 스레드가 종료될 때까지 프로그램을 종료하지 않고 기다린다.
  - 스레드는 무엇을 바라는가? 일반적으로 모든 하드웨어 스레드를 활용해 병렬성의 장점을 극대화하도록 프로그램 구조를 만드는 것 즉, 프로그램을 작은 태스크 단위로 구조화하는 것이 목표다. 하지만 태스크 변환 비용을 고려해 너무 작은 크기는 아니어야 한다.

#### 동기 API와 비동기 API

- 자바 8 스트림을 이용해 명시적으로 병렬 하드웨어를 이용할 수 있다. 외부 반복(명시적 for 루프)을 내부 반복(스트림 메서드 사용)으로 바꿔야 한다. 그리고 스트림에 parallel() 메서드를 이용해 자바 런타임 라이브러리가 복잡한 스레드 작업을 하지 않고 병렬로 요소가 처리되도록 할 수 있다.
- f와 g를 실행하는데 오랜 시간이 걸린다고 가정하자. 별도의 스레드로 f와 g를 실행해 이를 구현할 수 있다. 의도는 좋지만 단순했던 코드가 복잡하게 변한다.
- 문제의 해결은 비동기 API라는 기능으로 API를 바꿔서 해결할 수 있다.
  - 동기 API는 보통 결과가 나올 때까지 물리적 반환을 지연시킴으로 **블로킹** API로도 알려져있다. I/O 작업이 가장 흔한 예다. 반면 비동기 API는 블록하지 않는 I/O를 구현한다. 비동기 API는 보통 결과를 기다리지 않고 I/O 작업을 시작시킨다. 
  - Future 형식 API
  - 리액티브 형식 API
  - 두 대안 모두 코드를 복잡하게 만든다고 생각할 것이다. 하지만 API는 명시적으로 스레드를 처리하는 코드에 비해 사용 코들르 더 단순하게 만들어주며 높은 수준의 구조를 유지할 수 있게 도와준다.
  - 또한 계산이 오래 걸리는 메서드(수 밀리초 이상), 네트워크나 사람의 입력을 기다리는 메서드에 이들 API를 잘 활용하면 애플리케이션의 효율성이 크게 향상된다.
- 잠자기(그리고 기타 블로킹 동작)는 해로운 것으로 간주: 스레드는 잠들어도 여전히 시스템 자원을 점유한다. 스레드가 많아지고 그 중 대부분이 잠을 잔다면 문제가 심각해진다. 스레드 풀에서 잠을 자는 태스크는 다른 태스크가 시작되지 못하게 막으므로 자원을 소비한다는 사실을 기억하자.
- 현실성 확인: 블록할 수 있는 모든 동작을 비동기 호출로 구현한다면 병렬 하드웨어를 최대한 활용할 수 있다. 현실적으로는 '모든 것은 비동기'라는 설계 원칙을 어겨야 한다.

#### CompletableFuture와 콤비네이터를 이용한 동시성

- 상황에 따라 get()을 기다리는 스레드가 큰 문제가 되지 않으므로 기존 자바 8의 Future를 이용한 방식도 해결 방법이 될 수 있다. 하지만 어떤 상황(예를 들어 서비스에 여러 질의를 처리하는 상황)에서는 많은 수의 Future를 사용해야 한다. 
- 이런 상황에서는 CompletableFuture와 콤비네이터를 이용해 get()에서 블록하지 않을 수 있고 그렇게 함으로 병렬 실행의 효율성을 높이고 데드락은 피하는 최상의 해결책을 구현할 수 있다.

#### 발행-구독 그리고 리액티브 프로그래밍

- 프로그램이 스트림 모델에 잘 맞는 상황이라면 가장 좋은 구현이 될 수 있다. 하지만 보통 리액티비 프로그래밍 패러다임은 비싼 편이다. 스트림 패러다임은 두 개의 파이프라인으로 값을 분리 (포크처럼)하기 어려우며 두 개의 분리된 스트림에서 다시 결과를 합치기도 (조인처럼) 어렵다. 스트림은 선형적인 파이프라인 처리 기법에 알맞다.
- 자바 9에서는 java.util.concurrent.Flow의 인터페이스에 발행-구독 모델(또는 줄여서 pub-sub이라 불리는 프로토콜)을 적용해 리액티브 프로그래밍을 제공한다.
- 살펴볼 세 가지 플로 API  
  - **구독자**가 구독할 수 있는 **발행자**
  - 이 연결을 **구독(subscription)**이라 한다.
  - 이 연결을 이용해 **메시지**(또는 **이벤트**로 알려짐)를 전송한다.
- 데이터가 발행자(생산자)에서 구독자(소비자)로 흐름에 착안해 개발자는 이를 **업스트림(upstream)** 또는 **다운스트림(downstream)**이라 부른다.
- 플로 인터페이스의 개념을 복잡하게 만드는 두 가지 기능은 압력과 역압력이다. 처음에는 이 두 기능이 별로 중요해 보이지 않을 수 있지만 스레드 활용에서 이들 기능은 필수다.
- 역압력
  - Publisher에서 Subscriber로 정보를 전달한다. 정보의 흐름 속도를 역압력(흐름 제어)으로 제어 즉 Subscriber에서 Publisher로 정보를 요청해야 할 필요가 있을 수 있다.
  - Publisher는 여러 Subscriber를 갖고 있으므로 역압력 요청이 한 연결에만 영향을 미쳐야 한다는 것이 문제가 될 수 있다.
  - Subscription 객체는 cancel, request처럼 Subscriber와 Publisher와 통신할 수 있는 메서드를 포함한다.
  - Publisher는 Subscription 객체를 만들어 Subscriber로 전달하면 SubScriber는 이를 이용해 Publisher로 정보를 보낼 수 있다.

#### 리액티브 시스템 vs 리액티브 프로그래밍

- 리액티브 시스팀(reactive system): 런타임 환경이 변화에 대응하도록 전체 아키텍처가 설계된 프로그램
  - 리액티브 시스템이 가져야할 공식적인 속성은 [Reactive Manifesto](https://www.reactivemanifesto.org/)에서 확인할 수 있다. 
  - 반응성(responsive): 큰 작업을 처리하느라 간단한 질의 응답을 지연하지 않고 실시간으로 입력에 반응하는 것
  - 회복성(resillent): 한 컴포넌트의 실패로 전체 시스템이 실패하지 않아야 함
  - 탄력성(elastic): 시스템이 자신의 작업 부하에 맞게 적응하며 작업을 효율적으로 처리함을 의미
  - 메시지 주도(message-driven): 박스와 채널 모델에 기반한 API를 갖고 있는데 여기서 컴포넌트는 처리할 입력을 기다리고 결과를 다른 컴포넌트로 보내면서 시스템이 반응한다.
-  여러 가지 방법으로 이런 속성을 구현할 수 있지만 java.util.concurrent.Flow 관련된 자바 인터페이스에서 제공하는 **리액티브 프로그래밍** 형식을 이용하는 것도 주요 방법 중 하나다. 

### Chapter16. CompletableFuture: 안정적 비동기 프로그래밍


