---
layout: post
title: Day8 - 컴퓨터 역사/구조/연산
categories: wps
tags: [fastcampus, computer-science]
---

## 시작하며

- 프로그래머 : 컴퓨터 프로그램을 만드는 사람
- 프로그래밍 : 컴퓨터 프로그램을 만드는 일
- 프로그램 : 명령어 집합
- 컴퓨터 프로그램 : 컴퓨터에 의해 실행될 수 있는 일련의 기능 모음
- 컴퓨터 : 전자계산기…?!

## 컴퓨터의 역사

```
수학자들이 계산을 빠르게 하기 위해 고안되기 시작. 연구를 해보니 기계에 십진법 보다 이진법이 더 빠른 계산에 용이.

- 최초의 다용도 디지털(0과 1) 컴퓨터 : ENIAC
- 최초의 프로그램 내장방식 컴퓨터 : EDSAC
- 진공관 : 제 1세대 컴퓨터
- 트랜지스터 : 제 2세대 컴퓨터
- 직접회로(IC) : 제 3세대 컴퓨터

현재는 기술의 발전으로 하나의 칩에 트랜지스터 개수가 엄청나게 들어간다.
```

### 전자 컴퓨터의 탄생 (1930~1950)

#### 1. 초기 전자 컴퓨터
메모리에 프로그램을 저장하지 않았다. 메모리를 오직 데이터 저장을 위해 사용했다. **외부**에 프로그래밍 되었다. (ENIAC)

#### 2. 폰 노이만 모델에 기초한 컴퓨터
폰 노이만은 프로그램과 데이터가 **메모리**에 저장되어야 한다고 제안했다. 그의 제안에 따르면, 새로운 작업을 할 때마다 기계를 재배선하고 수백 개의 스위치를 켜고 끄는 대신 프로그램을 변경하기만 하면 된다. (EDSAC, EDVAC)

### 컴퓨터 세대 (1950~현재)
1. 제 1세대 : 진공관
2. 제 2세대 : 트랜지스터 사용, 컴퓨터의 크기와 단가를 줄임
3. 제 3세대 : 직접회로(IC, 한 개의 칩에 **트랜지스터**와 회로 및 다른 구성요소들이 들어있음), 소프트웨어 프로그램들을 사용할 수 있게 됨
4. 제 4세대 : 마이크로컴퓨터가 출현, 최초의 데스크탑 계산기가 사용 되었다. 이 세대에 네트워크도 출현
5. 제 5세대 : 랩탑 컴퓨터의 출현, 보조기억장치 개선 등


## 컴퓨터의 구조

```
입력 장치 : 키보드, 마우스, ...
출력 장치 : 모니터, 프린터, 스피커, ...
기억 장치
	- 주기억 장치 : RAM / 빠름 / 전원이 꺼지면 데이터가 지워짐
	- 보조기억 장치 : HDD / 느림 / 전원이 꺼져도 데이터가 지워지지 않음
연산장치 + 제어장치 : 중앙처리 장치 (CPU, central processing unit)
```

![](https://pinstinct.github.io/image/wps-computer-architecture.png)

### 중앙처리 장치

- ALU : 산술 연산, 논리 연산
- 레지스터 : 데이터를 임시보관하는 빠른 속도의 저장소
  - 데이터 레지스터 : 입력데이터를 위한 R1, R2 / 출력데이터를 위한 R3
  - 명령어 레지스터 : I(Instruction Register), 명령어 저장/실행
  - 프로그램 카운터 : PC, 현재 실행중인 명령어 유지/완료 후 다음 명령어 가르킴

### 메모리 계층

빠른 메모리는 비싸다. 그렇기 때문에 메모리를 계층적으로 구성한다.

- Fastest speed, Register : CUP안 레지스터
- Fater speed, Cache memory : 자주 사용하는 것을 저장
- Fast speed, Main memory

메인 메모리에 보관된 데이터를 직접 변경할 수 없다. CPU로 이동한 후, CPU의 레지스터에 데이터가 보관된 상태에서 연산된 후 변경된 값을 다시 메인 메모리로 전송한다.



## 폰노이만 구조 vs 하버드 구조

### 폰 노이만 구조

```
- 프로그램 메모리와 데이터 메모리가 구분되어 있지 않고 하나의 메모리를 가지고 있는 구조
- 메모리 속박 문제 및 버스 병목 문제를 가짐
```

#### 1. 4개의 하부 시스템

- 메모리 : 저장공간이다. 메모리는 프로그램과 데이터가 처리되는 동안 저장되어 있는 곳이다.
- 산술논리회로(ALU) : 계산과 논리 연산이 이루어지는 곳이다.
- 제어 장치 : 메모리와 산술논리회로, 입출력기와 같은 하부시스템의 동작을 제어한다.
- 입출력기

#### 2. 저장된 프로그램 개념

폰 노이만 모델은 프로그램 메모리에 프로그램이 저장되어야 한다. 이것은 데이터가 메모리에만 저장되었던 초기 컴퓨터 구조와 완전히 다르다. 작업을 위한 프로그램은 일련의 스위치들을 조작하거나 배선된 시스템을 변경하여 실행되었다. 현재 컴퓨터들의 메모리는 프로그램과 관련된 데이터를 모두 취급한다. 이 사실은 **데이터와 프로그램 모두 메모리에 저장**되기 때문에 동일한 형태를 가져야 한다는 것을 암시한다. 사실 이들은 **이진 형태**로 저장된다.

#### 3. 순차적인 명령의 실행

프로그램은 한정된 명령어(instruction)들로 구성되어 있다. 이 모델에서 제어 장치는 메모리로부터 한 개의 명령어를 가져오고, 해석한 후 실행한다.다시 말해서 명령어는 하나씩 실행된다.

### 하버드 구조

```
- 프로그램 메모리와 데이터 메모리가 물리적으로 분리
- 속도가 빠름
- 구성에 비용이 많이 들며 복잡
```



### 하버드 + 폰 노이만

최신의 CPU 설계는 하버드와 폰 노이만 양쪽 모두의 아키텍쳐를 도입하고 있다. 캐시 메모리 장치는 명령용과 데이터용으로 분리해 하버드 구조를, CPU와 main memory는 폰 노이만 구조를 적용한다. (예: L1캐시, L2캐시)



## 컴퓨터 소프트웨어

### 시스템 소프트웨어

- 운영체제
- 로더
- 장치 드라이버
- 컴파일러
- 어셈블러
- 링커
- 유틸리티

### 응용 소프트웨어 (=애플리케이션)

- OS 상에서 실행되는 모든 프로그램 (**시스템에 종속적**)
- 워드프로세서, 웹브라우저, 게임, ...



## 데이터 표현

### 컴퓨터 내부의 데이터

- 비트(bit) : 컴퓨터에 저장될 수 있는(0과 1) 데이터의 가장 작은 단위
- 비트 패턴 : 한 개짜리 비트는 데이터 표현 문제를 해결할 수 없다. 서로 다른 타입의 데이터를 표현하기 위해 비트 패턴(bit pattern)이나 비트열을 사용한다. 컴퓨터 메모리는 데이터를 비트 패턴으로 저장한다. 다시말해 컴퓨터에 들어갈 때 **코드화**되고 사용자에게 표현될 때 원상복구된다.
- 바이트(byte) : 관삽승 길이 8bit를 1byte라 부른다.

### 데이터 표현

#### 텍스트

비트 패턴들의 다양한 집합들이 텍스트 기호를 표현하기 위해 디자인되어 왔다. 각각의 집합을 코드(code)라 부르고, 기호 표현의 처리 작업을(coding)이라 부른다.

- ANSI는 정보교환용 미국표준 코드(ASCII)라고 부르는 코드를 개발했다. 이 코드는 각각의 기호에 대해 7비트를 사용한다.  이것은 128(2^7)개의 다른 기호들이 이 코드에 의해 정의될 수 있다는 것을 의미한다.
- 유니코드 이전의 코드들 중 어떤 것들도 영어 이외의 언어에 속하는 기호들을 표현할 수 없었다. 즉 더 많은 공간을 가진 코드가 필요했다. 유니코드는 16비트를 사용하고 65,536(2^16)개 기호를 표현할 수 있다.
- ISO는 32비트 패텬을 사용하는 코드를 만들었다. 이 코드는 4,294,967,296(2^32)개의 기호를 표현할 수 있다.

```
인코딩 : 데이터를 코드화 한 것
  - UTF-8 : 조합형 문자 인코딩 방식
  - EUC-KR : 완성형 문자 인코딩 방식
조합형 방식 : 한글을 예로 들면 초성, 중성, 종성을 하나의 바이트로 인식하고 조합하여 총 3바이트 문자로 인식한다. 모든 문자를 자유롭게 표현가능하다.
완셩형 방식 : 모든 경우의 수를 매핑하는 방식이다. 매핑하지 않은 글자를 입력하면 이상한 문자를 출력한다. 그렇기 때문에 확장성이 떨어진다.
```

#### 이미지

이미지들은 오늘날 컴퓨터에서 **비트맵 그래픽**과 **벡터 그래픽**이라는 두 가지 방법 중 하나로 표현한다.

#### 오디오

오디오는 소리와 음악의 표현이다. 소리와 음악을 저장하는 어떠한 표준이 없다. 개념은 오디오를 **디지털** 데이터로 변환하고 디지털 데이터를 저장하기 위해 비트 패턴을 사용한다.

#### 비디오

비디오는 순차적인 이미지들의 표현이다.

#### 16진 표기법

사람들이 비트패턴을 조작하기 어렵고 너무 길다. **16진 표기법(hexadecimal notation)**이 도움이 될 수 있다. 이것은 16개의 기호(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F)로 표시한다. **4비트는 16진수 한개로 표현**한다.

```
1111 1100 1110 0100
 F    C    E    4   =  OxFCE4
```

#### 8진 표기법

**8진 표기법(octal notation)**은 8개의 기호(0, 1, 2, 3, 4, 5, 6, 7)로 표시한다. **3비트는 8진수 한개로 표현**한다.

```
1 111 110 011 100 100
1  7   6   3   4   4  = Oo176344
```



## 수 표현

**정수(integer)**는 소수점이 없는 수를 말한다. 정수는 양수와 음수가 있다. **음수(negative integer)**는 음의 무한대에서 0까지이고, **양수(positivie integer)**는 0에서 양의 무한대까지 걸쳐있다. 모든 수를 저장하기 위해서는 무한 개의 비트가 필요하다. 때문에 컴퓨터 메모리를 효율적으로 이용하기 위해 다음과 같은 표현법이 존재한다.

- Unsigned (부호없음)
- Signed (부호있음)
  - Sign-magnitude
  - One's complement
  - Two's complement

현재 가장 일반적으로 사용되는 표현법은 **2의 보수법**이다.

### 부호 없는 정수형

**부호 없는 정수(unsigned integer)**의 범위는 0에서 양의 무한대까지이다. 컴퓨터에서 부호 없는 최대 정수는 컴퓨터다 부호 없는 정수를 저장하기 위하여 할당하는 비트 수에 따라 달라진다. N은 부호없는 정수를 표현하기 위해 할당된 비트 수를 말한다.

```
range : 0 ~ (2^N - 1)
```

부호 없는 정수 표현은 정수의 부호를 저장할 필요가 없으므로 저장의 효율을 높일 수가 있다 .

### 부호와 크기 형식

부호와 크기를 갖는 형식으로 정수를 저장하려면 부호를 표현하기 위해 1비트가 필요하다. **0은 양수, 1은 음수**. 이 말은 정수를 표현하는데 8비트가 할당된 컴퓨터에서는 표현하고자 하는 절대값에 7비트만 사용할 수 있다는 것이다.

```
range : -(2^N-1 - 1) ~ (2^N-1 - 1)
```

이 시스템에서 0에도 -0과 +0이 존재한다는 것을 주의해햐 한다.

```
8비트가 할당된 시스템에서 -0과 0은 다음과 같다.
+0 = 0000 0000
-0 = 1000 0000
```

부호와 크기를 갖는 표현법은 **오늘날 컴퓨터에서 부호 있는 수를 저장하는데 사용하지 않는다.** 이유는 다음과 같다.

- 덧셈과 뺄셈이나 같은 연산을 직접 적용할 수 없다
- 0에 대한 표현이 두 가지나 존재한다는 것

하지만 이런 표현법도 장점이 있다. 10진수와 2진수 변환이 쉽다는 것이다. 이런 이유로 수에 대한 연산이 필요없는 응용에 적합핟. 예를 들면 아날로그 신호를 디지털 신호로 변환할 때 사용한다.

### 1의 보수 형식

**1의 보수 표현법(one's complement representation)**은 양수를 표현하기 위하여 부호 없는 정수 표현법에서 채택한 관례를 이용하고, 음수를 표현하기 위하여 양수의 보수를 취한다. 보수는 0은 1로, 1은 0으로 바꿔서 얻을 수 있다. 맨 왼쪽 비트는 부호를 나타낸다.  0은 양수, 1은 음수. N은 하나의 정수를 표현할 때 할당받을 수 있는 최대 비트수이다.

```
range : -(2^N-1 - 1) ~ (2^N-1 - 1)
```

이 시스템에서 0에도 -0과 +0이 존재한다는 것을 주의해햐 한다.

```
8비트가 할당된 시스템에서 -0과 0은 다음과 같다.
+0 = 0000 0000
-0 = 1111 1111
```

1의 보수 표현법 부호와 크기형식과 같은 이유로 컴퓨터에서 수를 저장하는데 사용하지 않는다. 그러나 2의 보수 표현법에 기초가 되므로 중요하다.

### 2의 보수 형식

1의 보수 표현법은 두 가지 0에 대한 표현이 있다. 이런 문제점을 **2의 보수 표현법(two's complement representation)**이 해결해준다. 맨 왼쪽 비트는 부호를 나타낸다.  0은 양수, 1은 음수.

```
range : -(2^N-1) ~ (2N-1 - 1)
```

2의 보수형식에서는 0이 1개이다.

```
8비트가 할당된 시스템에서 0은 다음과 같다.
0 = 0000 0000
```

2의 보수를 취한다는 것은 맨 오른쪽 비트부터 처음으로 1이 나오는 비트 값은 그대로 놔두고 나머지 비트는 모두 바꿈으로써 얻을 수 있다. **2의 보수 표현법은 컴퓨터에서 정수를 저장하기 위한 일반적인 방법**이다.



## 비트 연산

비트 연산은 크게 두 가지 영역으로 나눌 수 있다. 산술연산과 논리연산이다.

### 산술 연산(arithmetic operation)

  덧셈, 뺄셈, 곱셉, 나눗셈 등이 있다. 컴퓨터는 덧셈밖에 못하는데 뺄셈은 음수로 더하고, 곱셈은 덧셈을 한 횟수, 나눗셈은 뺄셈을 한 횟수로 구현할 수 있다.

예로 2의 보수 형식의 정수 덧셈 연산 법을 살펴보자. 현재 대부분의 컴퓨터에서 정수를 저장하기 위해 **2의 보수 표현법**이 유일하게 사용하기 때문이다.

2의 보수 형식에서 덧셈은 10진수의 덧셈과 같다. 각 자릿수에 따라 덧셈을 하면 된다. 그리고 **캐리(carry)**가 발생하면 다음 자리수에 더하면 된다. 만약 제일 왼쪽 열의 덧셈 후에 캐리가 발생하면 캐리를 버린다.

```
8비트 메모리 할당
범위 : -(2^8-1) ~ (2^8-1 - 1) = -128 ~ 127

(+24) + (-17) = (+7)

carry 1 1 1 1
        0 0 0 1 1 0 0 0
        1 1 1 0 1 1 1 1
result  0 0 0 0 0 1 1 1

마지막 캐리는 버린다.
```



#### 오버플로(Overflow)

저장하고자 하는 메모리 할당 영역을 벗어나는 수를 저장하고자 할 때 발생하는 에러이다. 컴퓨터에서 산술 연산을 할 때, 각 수와 결과 값이 메모리 할당에서 정의한 범위 내에 반드시 포함되어야 한다는 것을 명심해야 한다. (예: 로켓 폭발  사건, 유투브 조회수에 마이너스 값 출력)

### 논리 연산(logical operation)

하나의 비트는 0 또는 1 값을 가진다. 0을 논리 값 **False**, 1은 논리 값 **True**이다. 논리 연산이 하나의 입력에 대해 수행되면 **단항 연산(unary operation)**이며, 두 개의 입력에 대해 논리 연산이 수행되면 **이진 연산(binary operation)**이다.

- Unary
  - NOT
- Binary
  - AND
  - OR
  - XOR

#### NOT 연산자

비트를 반전하여 0을 1로, 1을 0으로 바꾼다.  NOT 진리표(truth table)이다.

| x    | NOTx |
| ---- | ---- |
| 0    | 1    |
| 1    | 0    |

#### AND 연산자

두 입력 비트가 모두 1일 경우 1이며, 그 외의 경우는 0이다. AND 진리표(truth table)이다.

| x    | y    | x AND y |
| ---- | ---- | ------- |
| 0    | 0    | 0       |
| 0    | 1    | 0       |
| 1    | 0    | 0       |
| 1    | 1    | 1       |

**AND 연산자 절대 규칙** : 입력 중에 하나가 0이면 나머지 입력에 대해서 검사하지 않아도 된다. 결과 값이 0이라는 것을 바로 알 수 있다.

#### OR 연산자

두 입력 비트가 모두 0일 경우 0이며, 그 외의 경우는 1이다. OR 진리표(truth table)이다.

| x    | y    | x OR y |
| ---- | ---- | ------ |
| 0    | 0    | 0      |
| 0    | 1    | 1      |
| 1    | 0    | 1      |
| 1    | 1    | 1      |

**OR 연산자 절대 규칙** : 입력 중에 하나가 1이면 나머지 입력에 대해서 검사하지 않아도 된다. 결과 값이 1이라는 것을 바로 알 수 있다.

#### XOR 연산자

두 입력 비트가 같을 경우에는 0, 그 외의 경우는 1이다. XOR 진리표(truth table)이다.

| x    | y    | x XOR y |
| ---- | ---- | ------- |
| 0    | 0    | 0       |
| 0    | 1    | 1       |
| 1    | 0    | 1       |
| 1    | 1    | 0       |

**XOR 연산자 절대 규칙** : 입력 중에 하나가 1이면, 결과는 다른 입력에 대해 NOT을 수행한 결과다.

#### 비트 마스크(mask)

AND, OR, XOR의 세 가지 논리 연산은 비트 패턴을 변경하기 위해 사용한다. 변경하고자 하는 비트 패턴을 **마스크**라고 불리는 비트 패턴과 AND, OR, XOR 연산을 통해 변경할 수 있다.

- 특정 비트 **0으로 설정(unset, force to 0)**
  - 목표 비트 패턴에서 특정 비트를 0으로 설정하기 위해서, 마스크에서 해당 비트를 0으로 설정
  - 변경할 필요가 없는 비트들에 대해서는 마스크의 해당 비트를 1로 설정
- 특정 비트 **1으로 설정(set, force to 1)**
  - 목표 비트 패턴에서 특정 비트를 1로 설정하기 위해서, 마스크에서 해당 비트를1로 설정
  - 변경할 필요가 없는 비트들에 대해서는 마스크의 해당 비트를 0으로 설정
- 특정 비트 **반전(flip)**
  - 목표 비트 패턴에서 특정 비트를 반전하기 위해서, 마스크에서 해당 비트를1로 설정
  - 변경할 필요가 없는 비트들에 대해서는 마스크의 해당 비트를 0으로 설정



## 32bit / 64bit

32bit CPU에서는 메모리 주소를 32자리 0과 1로 표현할 수 있다. 메모리 관리는 **운영체제**가 한다.

- 64bit 시스템에서 32bit 운영체를 사용하면 메모리를 4GB밖에 사용 못한다.
- 만약 그래픽 카드가 있다면 그래픽 카드 메모리를 제외하고 나머지 크기만큼만 메모리 사용이 가능하다. 그래픽 카드는 반드시 필요하기 때문에 우선순위가 있다.

x86(386, 486, …)은 32bit를 사용했기 때문에 32bit를 x86이라고 부른다.

```
1) 32비트(=4byte) 일 경우
2^32 = 2^2 * 2^30
     = 4 * 2^30
     = 4GB

2) 64비트(=8byte) 일 경우
2^64 = 192GB
```



| Unit     | Exact Number of Bytes | Approxiamtion |
| -------- | --------------------- | ------------- |
| kilobyte | 2^10(1024) bytes      | 10^3 bytes    |
| megabyte | 2^20(1,048,576) bytes | 10^6 bytes    |
| gigabyte | 2^30(1,072,741) bytes | 10^9 bytes    |
| terabyte | 2^40 bytes            | 10^12 bytes   |
| petabyte | 2^50 bytes            | 10^15 bytes   |
| exabyte  | 2^60 bytes            | 10^18 bytes   |



### IPv4 / IPv6

```
IPv4 8bit.8bit.8bit.8bit = 32bit
IPv6 8bit.8bit.8bit.8bit.8bit.8bit = 128bit
```

IPv6가 나온지는 오래됐지만 사용하지 않는 이유는 호환성 때문이다. 라우터같은 중간 장비들은 옛날 장비를 사용해서 아직 IPv4만 지원하기 때문이다. 현재는 점점 변경하고 있는 추세이다.



## QnA

- 유니코드에는 완성형과 조합형이 모두 있다.
  - 유니코드는 전 세계 문자를 표현하기 위해 각 글자에 code point를 할당해 놓은 것이다.
  - 유니코드를 사용하기 위한 방식이 **유니코드 인코딩** 방식으로, 유니코드의 code point를 컴퓨터가 이해하는 방식으로 변환했다는 것을 의미한다.
  - 유니코드 인코딩 방식에 UTF-8, UTF-16, UCS-2 등의 방식이 있다.
  - 유니코드 1.0 버전에는 한글이 완성형밖에 없었으나, 유니코드 2.0 버전에 초성/중성/종성이 포함되면서 조합형/완성형 모두 호환가능하게 되었다.
- 메모리 속박 문제 : 메모리를 읽고쓰는 속도보다 CPU계산속도가 훨씬빠르기 때문에 생겨난 현상이다. 즉, 메모리가 느리기 때문에 CPU가 기다리게 되므로 발생하는 문제이다.
- 비트 논리연산(주로 정수로 연산) vs 부울논리연산(주로 참/거짓으로 연산)
- 1바이트 8비트일까? 미국인들이 만들었기때문이다. 영어는 한 글자를 표현하는데 8비트를 사용하기때문에 1글자를 1바이트라고 표현
