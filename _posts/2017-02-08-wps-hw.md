---
layout: post
title: Day21 - HW
categories: wps
tags: [fastcampus, database, sql]
---


# Models

모델은 데이터 정보의 소스이다. 일반적으로 각 모델은 하나의 데이터베이스 테이블과 연결한다.

기본 사항:

- 각 모델은 `django.db.models.Model.`의 서브클래스인 파이썬 클래스이다.
- 모델의 각 **속성은 데이터베이스 필드**로 표현한다.
- 장고는 자동으로 생성한 데이터베이스 접근 API를 제공한다.

## Quick example

모델 예는 `first_name`과 `last_name`을 가지는 `Person`을 정의한다.

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
```

`first_name`과 `last_name`은 **모델의 필드**이다. 각 필드는 클래스 속성으로 지정하고, 각 속성은 데이터베이스 column과 연결된다.

위의 `Person`모델은 아래와 같은 데이터베이스를 만든다.

```sql
CREATE TABLE myapp_person (
    "id" serial NOT NULL PRIMARY KEY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```



- 테이블 이름

  - 장고는 자동적으로 '모델 클래스의 이름'과 '앱 이름'에서 데이터베이스 테이블 이름을 얻는다.
  - 위의 예에서 테이블 이름은 `myapp_person`이다.

- id 필드는 자동으로 추가된다. (override 불가)

  ​

## Using models

모델을 정의하자마자 그 모델을 *사용*할 것이라고 장고에게 알려야 한다. 장고에게 알리는 것은 설정 파일  `INSTALLED_APPS`에 추가하면 된다.

```python
INSTALLED_APPS = [
    #...
    'myapp',
    #...
]
```

`INSTALLED_APPS`에 새로운 앱을 추가한 후, `manage.py migrate`를 실행해야 한다.

## Fields

모델의 유일한 필수 부분이자, 가장 중요한 부분은 필드가 정의한 데이터베이스 리스트이다. 필드는 클래스 속성에 의해 지정된다.  clean, save, delete 같은 `models API`와 충돌하는 필드 이름을 고르지 않도록 주의하자.

### Field types

모델의 각 필드는 적절한 `Field` 클래스의 하나의 인스턴스여야 한다. 장고는 필드 클래스 유형을 사용하여 몇 가지를 결정한다.

-  column type : 데이터베이스에 저장할 데이터 종류 (예 : `INTEGER` , `VARCHAR` , `TEXT` )
-  **폼 필드**를 렌더링할 때, 사용할 기본 HTML `widget`

Django에는 수십 가지 내장 필드 타입이 있다. [model field reference](https://docs.djangoproject.com/en/1.10/ref/models/fields/#model-field-types)에서 전체 목록을 찾을 수 있다. 또한, 커스텀 모델 필드를 쉽게 만들수 있다.

### Field options

각 필드는 필드 별 인자 세트를 갖는다. 예를 들면, `CharField`는 `VARCHAR`의 사이즈를 지정하는 `max_length` 인자가 필요하다.

또한 모든 필드 타입으로 사용할 수 있는 공통 인자 세트가 있다. 모든 것은 옵션이다. 가장 자주 사용하는것만 요약해보자.

#### null

`True`면, 데이터베이스는 `NULL`이라는 빈 값을 데이터베이스에 저장할 것 이다. (Default `False`)

#### blank

`True` 면, 필드는 공백을 허용한다. (Default `False`)

**주의** : `null`과는 다르다. `null`은 순전히 데이터베이스 관련인 반면, `blank`는 유효성과 관련이다.

#### choices

필드의 choices로 사용할 (2- 튜플)을 반복 가능한 (예 : list 또는 tuple) 객체에 주어지면, 기본 폼 위젯은 표준 텍스트 필드 대신 선택 상자가되어 주어진 선택 사항으로 선택 항목을 제한한다.

```python
from django.db import models

class Person(models.Model):
    SHIRT_SIZES = (
        ('S', 'Small'),
        ('M', 'Medium'),
        ('L', 'Large'),
    )
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
```

각 튜플의 첫 번째 요소는 데이터베이스에 저장될 값이다. 두 번째 요소는 폼 위젯 또는 `ModelChoiceField` 에 의해 표시된다. 모델 인스턴스가 주어지면, choices 필드를 위한 표시 값은 `get_FOO_display()` 메서드를 사용해 에 접근할 수 있다.

```shell
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size
'L'
>>> p.get_shirt_size_display()
'Large'
```



#### default

기본 값을 위한 필드이다. 값 또는 호출가능한 객체면 가능하다. 만약 호출하는 경우라면, 새로운 객체가 생성될 때 마다 호출된다.

#### help_text

위젯과 함께 표시될 추가 "help" 텍스트이다. 필드를 폼에 사용하지 않을지라도 문서화에 유용하다.

#### primary_key

`True`면, 이 필드는 모델의 기본 키이다.

모델의 어떤 필드에도 `primary_key=True` 를 지정하지 않으면, 장고가 기본 키를 보유하는 `IntegerField` 를 자동으로 추가한다. 그래서 디폴트 기본키 동작을 재정의하려는 경우가 아니면, 어떤 필드에도 `primary_key=True`를 설정할 필요가 없다.

기본 키 필드는 **읽기 전용**입니다. 기존 객체의 기본 키 값을 변경하고 저장하면, 이전 객체와 함께 새로운 객체가 생성된다.

#### unique

`True`면, 이 필드는 테이블 전체에서 유일해야 한다.

### Automatic primary key fields

기본적으로 장고는 각 모델에 다음의 필드를 제공한다.

```python
id = models.AutoField(primary_key=True)
```

자동 증가 기본 키이다. 만약 커스텀 기본 키를 지정하고 싶다면, 필드 중 하나에 `primary_key=True` 를 지정한다. 장고가 `Field.primary_key`를 명시적으로 설정한 것을 알면, 자동 증가 기본키를 추가하지 않는다.

각 모델은 `primary_key=True` (명시적으로 선언되거나 자동으로 추가됨)를 갖기 위해 정확히 하나의 필드가 필요하다.

### Verbose field names

`ForeignKey`, `ManyToManyField`, `OneToOneField`를 제외한 각 필드 타입은 선택적인(optional) 첫번째 위치 인자로 verbose name을 취한다. 만약 verbose 이름이 주어지지 않으면, 장고는 필드의 속성 이름을 사용해 자동으로 생성한다. 이때 underscore(_)는 spaces(공백)으로 변환한다.

```python
# verbose name is "person's first name"
first_name = models.CharField("person's first name", max_length=30)

# verbose name is "first name"
first_name = models.CharField(max_length=30)
```

관례상 `verbose_name`의 첫 글자를 대문자로 사용하지 않습니다. 장고는 필요할 때 자동으로 첫 글자를 대문자로 변환한다.



### Relationships

분명히 관계형 데이터베이스의 힘은 테이블을 서로 연관시키는 데 있다. 장고는 데이터베이스 관계의 가장 일반적인 세 가지 유형을 정의하여 제공한다.  many-to-one, many-to-many and one-to-one.

#### Many-to-one relationships

다대일 관계를 정의하려면 `django.db.models.ForeignKey`를 사용한다 . 다른 `Field` 타입과 마찬가지로 모델의 클래스 속성으로 포함하여 사용한다. `ForeignKey` 모델과 관련된 클래스 **위치 인자**가 필요하다.

예를 들어 `Car` 모델이 `Manufacturer`를 가진다면 다음 정의를 사용한다. 즉, `Manufacturer` 가 여러 자동차를 생산하지만 각 `Car`는 오직 하나의 `Manufacturer`를 가진다.

```python
from django.db import models

class Manufacturer(models.Model):
    # ...
    pass

class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
    # ...
```

`재귀 관계`(그 자체와 다 대일 관계가 있는 객체)와 `아직 정의되지 않은 모델과 관계`를 만들 수 있다. 재귀 관계를 만들려면 `models.ForeignKey('self', on_delete = models.CASCADE)`를 사용한다. 아직 정의되지 않은 모델과 관계를 작성해야하는 경우 **모델 오브젝트 자체가 아닌 모델 이름을 사용**할 수 있다.

```python
from django.db import models

class Car(models.Model):
    manufacturer = models.ForeignKey(
        'Manufacturer',
        on_delete=models.CASCADE,
    )
    # ...

class Manufacturer(models.Model):
    # ...
    pass
```

필수는 아니지만, 모델의 이름이 될 `ForeignKey` 필드의 이름(위의 예에서 manufacturer)이 소문자로 할 것을 권장한다. 물론 원하는대로 필드를 호출 할 수 있다.

```python
class Car(models.Model):
    company_that_makes_it = models.ForeignKey(
        Manufacturer,
        on_delete=models.CASCADE,
    )
    # ...
```



#### Many-to-many relationships

다대다 관계를 정의하려면 `ManyToManyField`를 사용한다. 다른 `Field` 타입과 마찬가지로 모델의 클래스 속성으로 포함하여 사용한다. `ManyToManyField` 모델과 관련된 클래스 위치 인자가 필요하다.

예를 들어, `Pizza`에 여러 개의 `Topping` 객체가있는 경우 다음과 같이 표현할 수 있다. (`Topping` 이 여러 피자에있을 수 있으며, 각 `Pizza` 에 여러 토핑이있을 수 있다.)

```python
from django.db import models

class Topping(models.Model):
    # ...
    pass

class Pizza(models.Model):
    # ...
    toppings = models.ManyToManyField(Topping)
```

`ForeignKey`와 마찬가지로 `재귀 관계`(그 자체와 다 대다 관계가 있는 객체)와 `아직 정의되지 않은 모델과의 관계`를 만들 수 있다. 재귀 관계를 만들려면 `models.ForeignKey('self', on_delete = models.CASCADE)`를 사용한다. 아직 정의되지 않은 모델과 관계를 작성해야하는 경우 **모델 오브젝트 자체가 아닌 모델 이름을 사용**할 수 있다.

필수는 아니지만, `ManyToManyField`의 이름(위의 예에서의 toppings)은 관련된 모델 객체 세트를 설명하는 복수형으로 사용할 것을 권장한다.

어떤 모델이 `ManyToManyField`를 가지고 있는지 중요하지 않지만, 두 모델 중 **하나에만** 넣어야 한다.

일반적으로 `ManyToManyField` 인스턴스는 폼에서 편집할 객체 안에 있어야 한다. 위의 예에서 (Topping이 pizzas의 ManyToManyField를 갖는것보다) toppings는 Pizza 안에 있다. pizza가 topings를 가지는게 topping이 여러개의 피자를 가지는거보다  더 자연스러운 생각이기 때문이다. 위에 설정된 방식대로 `Pizza` 양식을 사용하면 사용자가 토핑을 선택할 수 있다.



#### Extra fields on many-to-many relationships

피자와 토핑을 믹싱하고 매칭하는 것과 같은 단순한 다대다 관계 만 처리 할 때는 표준 `ManyToManyField`만 있으면된다. 그러나 때로는 두 모델 간의 관계에 데이터를 연결해야 할 수도 있다.

예를 들어, 뮤지션들이 속한 뮤지컬 그룹을 추적하는 어플리케이션의 경우를 생각해보자. person과 멤버가 속한 group 사이에 다대다 관계가 있다. 이 관계를 표현하기 위해 `ManyToManyField`를 사용할 수 있다. 그러나 그룹에 가입한 날짜와 같이 수집하려는 멈버십 정보의 세부 정보가 많이 있다.
